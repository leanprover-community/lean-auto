import Lean
import Auto.Lib.MonadUtils
import Auto.Lib.ExprExtra
import Auto.Lib.MetaExtra
import Auto.Translation.ReifM
import Auto.Translation.LamUtils
import Auto.Translation.SMTAttributes
import Auto.MathlibEmulator
import Auto.Embedding.LamChecker
import Auto.Embedding.LamInhReasoning
open Lean

initialize
  registerTraceClass `auto.buildChecker
  registerTraceClass `auto.lamReif.newChkStep
  registerTraceClass `auto.lamReif.printValuation
  registerTraceClass `auto.lamReif.printProofs
  registerTraceClass `auto.lamReif.printResult
  registerTraceClass `auto.lamReif.prep.def
  registerTraceClass `auto.lamReif.prep.printResult

namespace Auto.LamReif
open Embedding.Lam

/--
  We require that all instances of polymorphic constants,
    including `∀`, `∃`, `BitVec`, are turned into free variables
    before being sent to `LamReif.` Since propositional
    implication `→` has the same representation as `∀` in Lean `Expr`,
    we also require that they are turned into free variables.
  In this way, the expression that `LamReif` receives is an
    essentially higher-order term that can be reified directly.
-/
structure State where
  -- Maps previously reified type to their type atom index
  tyVarMap      : HashMap Expr Nat                := {}
  -- Maps previously reified expressions to their term atom index
  -- Whenever we encounter an atomic expression, we look up
  --   `varMap`. If it's already reified, then `varMap`
  --   tells us about its index. If it's not reified, insert
  --   it to `varMap`.
  varMap        : HashMap Expr Nat                := {}
  -- `tyVal` is the inverse of `tyVarMap`
  -- The `e : Expr` is the un-lifted valuation of the type atom
  -- The `lvl : level` is the sort level of `e`
  -- Let `u ← getU`. The interpretation of the sort atom would be
  --   `GLift.{lvl, u} e`
  tyVal         : Array (Expr × Level)            := #[]
  -- The `e : Expr` is the un-lifted counterpart of the interpretation of
  --   the term atom
  -- The `s : LamSort` is the λ sort of the atom
  -- The interpretation of the sort atom would be `s.upfunc e`
  varVal        : Array (Expr × LamSort)          := #[]
  -- lamILTy
  lamILTy       : Array LamSort                   := #[]
  -- Inverse of `lamILTy`
  isomTyMap     : HashMap LamSort Nat             := {}
  /-
    This hashmap contains assertions that have external (lean) proof
    · The key `t : LamTerm` is the corresponding λ term,
      where all `eq, ∀, ∃` are not of import version
    · The first `e : Expr` is the proof of the assertion
    · The second `d : DTr` is the derivation of `e` from the context
    · The second `t' : LamTerm` is `← mkImportVersion t`
    · The thrid `n : Nat` is the position of the assertion in the `ImportTable`
    · To be precise, we require that `e : GLift.down t.interp`

    This field also corresponds to the `ImportTable` in `LamChecker.lean`
  -/
  assertions    : HashMap LamTerm (Expr × DTr × LamTerm × Nat)   := {}
  /-
    This hashmap contains lamsorts who has external proof of inhabitation
    · The key `s : LamSort` is the corresponding `λ` sort
    · The first `e : Expr` is an inhabitant of `s`
    · The second `DTr` is the derivation of `e` from the context
    · The third `n : Nat` is the position of the inhabitation fact in the `ImportTable`
  -/
  inhabitations : HashMap LamSort (Expr × DTr × Nat)    := {}
  -- Records the EvalResult and etoms generated by checksteps
  --   that produce etoms
  chkStepCache  : HashMap ChkStep (EvalResult × Array Nat) := {}
  -- The check step that produces a given etom
  etomChkStep   : HashMap Nat ChkStep             := {}
  -- We insert entries into `rTable` through two different ways
  -- 1. Calling `newChkStep`
  -- 2. Validness facts from the ImportTable are treated in `newAssertions`
  rst           : RTableStatus                    := {}
  -- `u` is the universe level that all constants will lift to
  -- Something about the universes level `u`
  -- Suppose `u ← getU`
  -- · `tyVal : Nat → Type u`
  -- · `LamValuation.{u}`
  -- · All the `GLift/GLift.up/GLift.down` has level parameter list `[?, u]`
  u             : Level
deriving Inhabited

abbrev ReifM := StateRefT State Reif.ReifM

@[inline] def ReifM.run' (x : ReifM α) (s : State) := Prod.fst <$> x.run s

#genMonadState ReifM

def getRTable : ReifM (Array REntry) := do return (← getRst).rTable

def getRTableTree : ReifM (BinTree REntry) := do return (← getRst).rTableTree

def getMaxEVarSucc : ReifM Nat := do return (← getRst).maxEVarSucc

def getLamEVarTy : ReifM (Array LamSort) := do return (← getRst).lamEVarTy

def getLamEVarTyTree : ReifM (BinTree LamSort) := do return (← getRst).lamEVarTyTree

def getChkMap : ReifM (HashMap REntry ChkStep) := do return (← getRst).chkMap

def checkerStats : ReifM (Array (String × Nat)) := do
  return #[("tyVal", (← getTyVal).size), ("varVal", (← getVarVal).size),
           ("ilLamTy", (← getLamILTy).size), ("assertions", (← getAssertions).size),
           ("chkMap", (← getChkMap).size), ("RTable", (← getRTable).size)]

def printCheckerStats : ReifM Unit := do
  let stats := (← checkerStats).map (fun (s, n) => "  " ++ s ++ s!": {n}")
  let ss := #["Checker Statistics:"] ++ stats
  trace[auto.buildChecker] (String.intercalate "\n" ss.data)

def printValuation : ReifM Unit := do
  let tyVal ← getTyVal
  for ((e, lvl), idx) in tyVal.zipWithIndex do
    trace[auto.lamReif.printValuation] "Type Atom {idx} := {e} : {Expr.sort lvl}"
  let varVal ← getVarVal
  for ((e, s), idx) in varVal.zipWithIndex do
    trace[auto.lamReif.printValuation] "Term Atom {idx} : {toString s} := {e}"
  let lamEVarTy ← getLamEVarTy
  for (s, idx) in lamEVarTy.zipWithIndex do
    trace[auto.lamReif.printValuation] "Etom {idx} : {toString s}"
  let lamIl ← getLamILTy
  for (s, idx) in lamIl.zipWithIndex do
    trace[auto.lamReif.printValuation] "LamILTy {idx} := {s}"

def printProofs : ReifM Unit := do
  let chkMap ← getChkMap
  for re in (← getRTable) do
    if let .some cs := chkMap.find? re then
      let .some n := (← getRst).findPos? re
        | throwError "printProofs :: Unexpected error"
      let etoms :=
        match (← getChkStepCache).find? cs with
        | .some (_, arr) =>
          if arr.size == 0 then m!"" else m!" and produces etoms {arr.data}"
        | .none => m!""
      trace[auto.lamReif.printProofs] "{n} : ChkStep ⦗⦗{cs}⦘⦘ proves ⦗⦗{re}⦘⦘{etoms}"
    else
      match re with
      | .valid [] t =>
        let .some (expr, _, n) := (← getAssertions).find? t
          | throwError "printProofs :: Unable to find assertion associated with {t}"
        trace[auto.lamReif.printProofs] "{n} : External fact ⦗⦗{← Meta.inferType expr}⦘⦘ proves ⦗⦗{re}⦘⦘"
      | .nonempty s =>
        let .some (expr, _, n) := (← getInhabitations).find? s
          | throwError "printProofs :: Unable to find inhabitation fact associated with {s}"
        trace[auto.lamReif.printProofs] "{n} : Inhabitation fact ⦗⦗{← Meta.inferType expr}⦘⦘ proves ⦗⦗{re}⦘⦘"
      | _ => throwError "printProofs :: Unexpected entry {re}"

def sort2LamILTyIdx (s : LamSort) : ReifM Nat := do
  let isomTyMap ← getIsomTyMap
  match isomTyMap.find? s with
  | .some n => return n
  | .none =>
    let lamILTy ← getLamILTy
    let idx := lamILTy.size
    setLamILTy (lamILTy.push s)
    setIsomTyMap (isomTyMap.insert s idx)
    return idx

def lookupTyVal! (n : Nat) : ReifM (Expr × Level) := do
  if let .some r := (← getTyVal)[n]? then
    return r
  else
    throwError "lookupTyVal! :: Unknown type atom {n}"

/-- Lookup valuation of term atom -/
def lookupVarVal! (n : Nat) : ReifM (Expr × LamSort) := do
  if let .some r := (← getVarVal)[n]? then
    return r
  else
    throwError "lookupVarVal! :: Unknown term atom {n}"

def lookupLamILTy! (idx : Nat) : ReifM LamSort := do
  if let .some s := (← getLamILTy)[idx]? then
    return s
  else
    throwError "lookupLamILTy! :: Unknown index {idx}"

def lookupAssertion! (t : LamTerm) : ReifM (Expr × DTr × LamTerm × Nat) := do
  if let .some r := (← getAssertions).find? t then
    return r
  else
    throwError "lookupAssertion! :: Unknown assertion {t}"

def lookupRTable! (pos : Nat) : ReifM REntry := do
  if let .some r := (← getRTable).get? pos then
    return r
  else
    throwError "lookupRTable! :: Unknown REntry {pos}"

def lookupREntryPos! (re : REntry) : ReifM Nat := do
  match (← getRst).findPos? re with
  | .some n => return n
  | .none =>
    match re with
    | .valid [] t =>
      match (← getAssertions).find? t with
      | .some (_, _, _, n) => return n
      | .none => throwError "lookupREntryPos! :: Unknown REntry {re}"
    | .nonempty s =>
      match (← getInhabitations).find? s with
      | .some (_, _, n) => return n
      | .none => throwError "lookupREntryPos! :: Unknown REntry {re}"
    | _ => throwError "lookupREntryPos! :: Unknown REntry {re}"

inductive REntryProof where
  | chkStep      : ChkStep → REntryProof
  | inhabitation : Expr → DTr → LamSort → REntryProof
  | assertion    : Expr → DTr → LamTerm → REntryProof

def lookupREntryProof? (re : REntry) : ReifM (Option REntryProof) := do
  match (← getChkMap).find? re with
  | .some cs => return .some (.chkStep cs)
  | .none =>
    match re with
    | .valid [] t =>
      match (← getAssertions).find? t with
      | .some (e, deriv, t, _) => return .some (.assertion e deriv t)
      | .none => return .none
    | .nonempty s =>
      match (← getInhabitations).find? s with
      | .some (e, deriv, _) => return .some (.inhabitation e deriv s)
      | .none => return .none
    | _ => return .none

def lookupREntryProof! (re : REntry) : ReifM REntryProof := do
  match ← lookupREntryProof? re with
  | .some proof => return proof
  | .none => throwError "lookupREntryProof! :: Unknown REntry {re}"

def lookupLamEVarTy! (idx : Nat) : ReifM LamSort := do
  if let .some s := (← getLamEVarTy)[idx]? then
    return s
  else
    throwError "lookupLamEVarTy! :: Unknown etom {idx}"

def lookupChkStepEtom! (cs : ChkStep) : ReifM (Array Nat) := do
  if let .some (_, arr) := (← getChkStepCache).find? cs then
    return arr
  else
    throwError "lookupChkStepEtom! :: ChkStep {cs} did not produce new etom"

def lookupChkStepResult! (cs : ChkStep) : ReifM EvalResult := do
  if let .some (er, _) := (← getChkStepCache).find? cs then
    return er
  else
    throwError "lookupChkStepEtom! :: ChkStep {cs} did not produce new etom"

def lookupEtomChkStep! (eidx : Nat) : ReifM ChkStep := do
  if let .some c := (← getEtomChkStep).find? eidx then
    return c
  else
    throwError "lookupEtomChkStep! :: Unknown etom {eidx}"

/--
  This should only be used at the meta level, i.e. in code that will
    be evaluated during the execution of `auto`
-/
def getLamTyValAtMeta : ReifM LamTyVal := do
  let varVal ← getVarVal
  let varTy := varVal.map Prod.snd
  let lamILTy ← getLamILTy
  let lamEVarTy ← getLamEVarTy
  return ⟨fun n => varTy[n]?.getD (.base .prop),
          fun n => lamILTy[n]?.getD (.base .prop),
          fun n => (lamEVarTy.get? n).getD (.base .prop)⟩

def resolveLamBaseTermImport : LamBaseTerm → ReifM LamBaseTerm
| .eqI n      => do return .eq (← lookupLamILTy! n)
| .forallEI n => do return .forallE (← lookupLamILTy! n)
| .existEI n  => do return .existE (← lookupLamILTy! n)
| .iteI n     => do return .ite (← lookupLamILTy! n)
| t           => pure t

/-- Models `resolveImport` on the `meta` level -/
def resolveImport : LamTerm → ReifM LamTerm
| .atom n       => return .atom n
| .etom _       => throwError "resolveImport :: etom should not occur here"
| .base b       => return .base (← resolveLamBaseTermImport b)
| .bvar n       => return .bvar n
| .lam s t      => return .lam s (← resolveImport t)
| .app s fn arg => return .app s (← resolveImport fn) (← resolveImport arg)

/--
  This is the inverse of `resolveImport`
  · When importing external proof `H : α`, we will reify `α`
    into `t : LamTerm` using `reifTerm`. The `t` returned
    by `reifTerm` has `eq` for `Eq`, `forallE` for `∀`,
    `existE` for `∃` and `ite` for `Auto.Bool.ite'`
  · It's easy to see that `t.interp` will not be definitionally
    equal to `α` because `=, ∀, ∃, ite'` within `α` operates on the
    original domain, while `=, ∀, ∃, ite'` in `t.interp` operates on
    the lifted domain
  · Therefore, we need to turn `=, ∀, ∃, ite'` in `t` into import
    version to get `t'`, and design an appropriate `ilVal`,
    such that `GLift.down t'.interp` is definitionally equal to `α`
-/
def mkImportVersion : LamTerm → ReifM LamTerm
| .atom n => return (.atom n)
| .etom _ => throwError "mkImportVersion :: etom should not occur here"
| .base b =>
  match b with
  | .eq s      => return .base (.eqI (← sort2LamILTyIdx s))
  | .forallE s => return .base (.forallEI (← sort2LamILTyIdx s))
  | .existE s  => return .base (.existEI (← sort2LamILTyIdx s))
  | .ite s     => return .base (.iteI (← sort2LamILTyIdx s))
  | b => return .base b
| .bvar n => return (.bvar n)
| .lam s t => do
  return .lam s (← mkImportVersion t)
| .app s t₁ t₂ => do
  return .app s (← mkImportVersion t₁) (← mkImportVersion t₂)

/--
  A new `ChkStep`. `res` is the expected result of the `ChkStep`
  Returns:
  1. Whether the checkstep produces a new REntry
  2. The `EvalResult` of this checkstep
-/
def newChkStep (c : ChkStep) (res? : Option EvalResult) : ReifM (Bool × EvalResult) := do
  trace[auto.lamReif.newChkStep] "New ChkStep {c}"
  -- For an etom-producing checkstep, evaluating it
  --   twice may yield different results. So, we lookup
  --   `chkStepCache` to see whether this checkstep has
  --   been evaluated before
  if let .some (res, _) := (← getChkStepCache).find? c then
    return (false, res)
  let ltv ← getLamTyValAtMeta
  let res := c.eval ltv.lamVarTy ltv.lamILTy ⟨← getRTableTree, ← getMaxEVarSucc, ← getLamEVarTyTree⟩
  if let .some res' := res? then
    if res' != res then
      throwError "newChkStep :: Result {res} of ChkStep {c} does not match with expected {res'}"
  match res with
  | .fail => throwError "newChkStep :: Evaluation of ChkStep {c} produces `fail`"
  | .addEntry re =>
    -- If `re` is already provable, do nothing
    if let .some _ ← lookupREntryProof? re then
      return (false, res)
    setChkStepCache ((← getChkStepCache).insert c (res, #[]))
    setRst ((← getRst).addEntry c re)
  | .newEtomWithValid s lctx t =>
    let re : REntry := .valid lctx t
    -- If `re` is already provable, do nothing
    if let .some _ ← lookupREntryProof? re then
      return (false, res)
    let eidx ← getMaxEVarSucc
    setChkStepCache ((← getChkStepCache).insert c (res, #[eidx]))
    setEtomChkStep ((← getEtomChkStep).insert eidx c)
    setRst ((← getRst).newEtomWithValid c re s)
  return (true, res)

/-- Returns the position of the entry inside the `RTable` -/
def addREntryToRTable (re : REntry) : ReifM Nat := do
  let pos := (← getRTable).size
  setRst ((← getRst).push re)
  return pos

/--
  `ty` is a reified assumption. `∀, ∃` and `=` in `ty` are supposed to
    not be of the import version
  The type of `proof` is definitionally equal to `GLift.down (← mkImportVersion ty).interp`
  Returns the position of `ty` inside the `validTable` after inserting it
-/
def newAssertion (proof : Expr) (deriv : DTr) (ty : LamTerm) : ReifM Unit := do
  -- Because of the way we `buildImportTableExpr`, we need to deduplicate facts
  if let .some _ ← lookupREntryProof? (.valid [] ty) then
    return
  let pos ← addREntryToRTable (.valid [] ty)
  -- This `mkImportVersion` must be called before we build the lval expression
  -- So it cannot be called on-the-fly in `buildImportTableExpr`
  let tyi ← mkImportVersion ty
  setAssertions ((← getAssertions).insert ty (proof, deriv, tyi, pos))

/--
  Returns `false` if `s` is subsumed by previous inhabited sorts
  Returns `true` if not
-/
def inhSubsumptionCheck (s : LamSort) : ReifM Bool := do
  if Inhabitation.trivialQuick s then
    return false
  let inhs := (← getRst).nonemptyMap
  for (s', _) in inhs.toArray do
    if Inhabitation.subsumeQuick s' s then
      return false
  return true

/-- The type of `inh` should be definitionally equal to `s.interpAsUnlifted` -/
def newInhabitation (inh : Expr) (deriv : DTr) (s : LamSort) : ReifM Unit := do
  -- Because of the way we `buildImportTableExpr`, we need to deduplicate facts
  if !(← inhSubsumptionCheck s) then
    return
  let pos ← addREntryToRTable (.nonempty s)
  setInhabitations ((← getInhabitations).insert s (inh, deriv, pos))

/-
  Computes `upFunc` and `downFunc` between `s.interpAsUnlifted` and `s.interpAsLifted`
  · `upFunc` is such that `upFunc f` is equivalent to `f↑`
  · `downFunc` is such that `downFunc f↑` is equivalent to `f`
  Return type:
  · The first `Expr` is `upFunc`
  · The second `Expr` is `downFunc`
  · The third `Expr` is `s.interpAsUnlifted`
  · The fourth `Expr` is `s.interpAsLifted`
-/
open Embedding in
partial def updownFunc (s : LamSort) : ReifM (Expr × Expr × Expr × Expr) :=
  match s with
  | .atom n => do
    let (orig, lvl) ← lookupTyVal! n
    let up := Expr.app (.const ``GLift.up [lvl, (← getU)]) orig
    let down := Expr.app (.const ``GLift.down [lvl, (← getU)]) orig
    return (up, down, orig, Expr.app (.const ``GLift [lvl, ← getU]) orig)
  | .base b => do
    let u ← getU
    let lvl₁ := Level.succ .zero
    let lift₁ := Expr.app (.const ``GLift [lvl₁, u])
    let liftup₁ := Expr.app (.const ``GLift.up [lvl₁, u])
    let liftdown₁ := Expr.app (.const ``GLift.down [lvl₁, u])
    match b with
    | .prop =>
      let ty := Expr.sort .zero
      return (liftup₁ ty, liftdown₁ ty, ty, lift₁ ty)
    | .bool =>
      let ty := Expr.const ``Bool []
      return (liftup₁ ty, liftdown₁ ty, ty, lift₁ ty)
    | .nat =>
      let ty := Expr.const ``Nat []
      return (liftup₁ ty, liftdown₁ ty, ty, lift₁ ty)
    | .int =>
      let ty := Expr.const ``Int []
      return (liftup₁ ty, liftdown₁ ty, ty, lift₁ ty)
    | .isto0 p =>
      let ty :=
        match p with
        | .xH => Expr.const ``String []
        | .xO .xH => Expr.const ``Empty []
        | _   => Expr.const ``Empty []
      return (liftup₁ ty, liftdown₁ ty, ty, lift₁ ty)
    | .bv n =>
      let ty := Expr.app (.const ``BitVec []) (.lit (.natVal n))
      return (liftup₁ ty, liftdown₁ ty, ty, lift₁ ty)
  | .func s₁ s₂ => do
    let (uf₁, df₁, ty₁, tyUp₁) ← updownFunc s₁
    let (uf₂, df₂, ty₂, tyUp₂) ← updownFunc s₂
    let fty := Expr.forallE `_ ty₁ ty₂ .default
    let ftyUp := Expr.forallE `_ tyUp₁ tyUp₂ .default
    let up := Expr.lam `_ fty (Expr.lam `_ tyUp₁ (.app uf₂ (.app (.bvar 1) (.app df₁ (.bvar 0)))) .default) .default
    let down := Expr.lam `_ ftyUp (Expr.lam `_ ty₁ (.app df₂ (.app (.bvar 1) (.app uf₁ (.bvar 0)))) .default) .default
    return (up, down, fty, ftyUp)

/--
  `(e, s)` is a pair from the `varVal` field of `LamReif.ReifM.State`
  Returns the lifted counterpart of `e`
-/
def varValInterp (e : Expr) (s : LamSort) : ReifM Expr := do
  let (up, _, _, _) ← updownFunc s
  return .app up e

section ILLifting

  open Embedding

  private def mkImportAux (s : LamSort) : ReifM (Expr × Expr × Expr × Expr × Level) := do
    let (upFunc, downFunc, ty, upTy) ← updownFunc s
    let sortOrig ← Expr.normalizeType (← Meta.inferType ty)
    let .sort uOrig := sortOrig
      | throwError "mkImportAux :: Unexpected sort {sortOrig} when processing sort {s}"
    return (upFunc, downFunc, ty, upTy, uOrig)

  set_option pp.universes true
  def mkIsomType (upFunc downFunc ty upTy : Expr) (uOrig : Level) : ReifM Expr := do
    let u ← getU
    let eq₁ : Expr := mkLambda `_ .default ty (mkAppN (.const ``Eq.refl [uOrig]) #[ty, .bvar 0])
    let eq₂ : Expr := mkLambda `_ .default upTy (mkAppN (.const ``Eq.refl [.succ u]) #[upTy, .bvar 0])
    let isomTy : Expr := mkAppN (.const ``IsomType.mk [uOrig, .succ u]) #[ty, upTy, upFunc, downFunc, eq₁, eq₂]
    return isomTy

  /-- Suppose `u ← getU`, this function returns a term of type `ILLift.{u} s.interpAsLifted` -/
  def mkImportingILLift (s : LamSort) := do
    let (upFunc, downFunc, ty, upTy, uOrig) ← mkImportAux s
    let isomTy ← mkIsomType upFunc downFunc ty upTy uOrig
    let ilLift := mkAppN (.const ``ILLift.ofIsomTy [uOrig, (← getU)]) #[ty, upTy, isomTy]
    return ilLift

end ILLifting

-- Functions that operates on the checker table
section Checker

  def nonemptyOfAtom (n : Nat) : ReifM (Option REntry) := do
    let .some (_, s) := (← getVarVal).get? n
      | throwError "nonemptyOfAtom :: Index {n} out of bound"
    if !(← inhSubsumptionCheck s) then
      return .none
    let (_, .addEntry re) ← newChkStep (.n (.nonemptyOfAtom n)) (.some (.addEntry (.nonempty s)))
      | throwError "nonemptyOfAtom :: Unexpected evaluation result"
    return .some re

  def nonemptyOfEtom (n : Nat) : ReifM (Option REntry) := do
    let .some s := (← getLamEVarTy).get? n
      | throwError "nonemptyOfEtom :: Index {n} out of bound"
    if !(← inhSubsumptionCheck s) then
      return .none
    let (_, .addEntry re) ← newChkStep (.n (.nonemptyOfEtom n)) (.some (.addEntry (.nonempty s)))
      | throwError "nonemptyOfEtom :: Unexpected evaluation result"
    return .some re

  def validOfIntros (v : REntry) (idx : Nat) : ReifM REntry := do
    if idx == 0 then
      return v
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.l (.validOfIntros p idx)) .none
      | throwError "validOfIntros :: Unexpected evaluation result"
    return re

  def validOfIntroMost (v : REntry) : ReifM REntry := do
    let .valid _ t := v
      | throwError "validOfIntroMost :: Unexpected entry {v}"
    let mut idx := 0
    let mut t := t
    while true do
      match t.intro1? with
      | .some (_, t') =>
        idx := idx + 1
        t := t'
      | .none => break
    validOfIntros v idx

  def validOfReverts (v : REntry) (idx : Nat) : ReifM REntry := do
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.l (.validOfReverts p idx)) .none
      | throwError "validOfReverts :: Unexpected evaluation result"
    return re

  def validOfRevertAll (v : REntry) : ReifM REntry := do
    let .valid lctx _ := v
      | throwError "validOfRevertAll :: Unexpected entry {v}"
    if lctx.length == 0 then
      return v
    validOfReverts v lctx.length

  def validOfAppend (v : REntry) (ex : Array LamSort) : ReifM REntry := do
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.l (.validOfAppend p ex.toList)) .none
      | throwError "validOfAppend :: Unexpected evaluation result"
    return re

  def validOfPrepend (v : REntry) (ex : Array LamSort) : ReifM REntry := do
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.l (.validOfPrepend p ex.toList)) .none
      | throwError "validOfPrepend :: Unexpected evaluation result"
    return re

  def validOfHeadBeta (v : REntry) : ReifM REntry := do
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.c (.validOfHeadBeta p)) .none
      | throwError "validOfHeadBeta :: Unexpected evaluation result"
    return re

  def validOfHnf (v : REntry) : ReifM REntry := do
    let mut v := v
    while true do
      let .valid _ t := v
        | throwError "validOfHnf :: Unexpected entry {v}"
      if !t.isHeadBetaTarget then
        break
      v ← validOfHeadBeta v
    return v

  def validOfBetaBounded (v : REntry) (bound : Nat) : ReifM REntry := do
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.c (.validOfBetaBounded p bound)) .none
      | throwError "validOfBetaBounded :: Unexpected evaluation result"
    return re

  def validOfBetaReduce (v : REntry) : ReifM REntry := do
    let .valid _ t := v
      | throwError "validOfBetaReduce :: Unexpected entry {v}"
    validOfBetaBounded v t.betaReduceHackyIdx

  def validOfExtensionalize (v : REntry) : ReifM REntry := do
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.c (.validOfExtensionalize p)) .none
      | throwError "validOfExtensionalize :: Unexpected evaluation result"
    return re

  def validOfEqSymm (v : REntry) : ReifM REntry := do
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.c (.validOfEqSymm p)) .none
      | throwError "validOfEqSymm :: Unexpected evaluation result"
    return re

  def validOfMp (vp : REntry) (vrw : REntry) : ReifM REntry := do
    let pp ← lookupREntryPos! vp
    let prw ← lookupREntryPos! vrw
    let (_, .addEntry re) ← newChkStep (.c (.validOfMp pp prw)) .none
      | throwError "validOfMp :: Unexpected evaluation result"
    return re

  def validOfMpAll (vp : REntry) (vrw : REntry) : ReifM REntry := do
    let pp ← lookupREntryPos! vp
    let prw ← lookupREntryPos! vrw
    let (_, .addEntry re) ← newChkStep (.c (.validOfMpAll pp prw)) .none
      | throwError "validOfMpAll :: Unexpected evaluation result"
    return re

  def validOfEtaExpand1At (v : REntry) (occ : List Bool) : ReifM REntry := do
    let pv ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.ca (.validOfEtaExpand1At pv occ)) .none
      | throwError "validOfEtaExpand1At :: Unexpected evaluation result"
    return re

  def validOfEtaReduce1At (v : REntry) (occ : List Bool) : ReifM REntry := do
    let pv ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.ca (.validOfEtaReduce1At pv occ)) .none
      | throwError "validOfEtaReduce1At :: Unexpected evaluation result"
    return re

  def validOfEtaExpandNAt (v : REntry) (n : Nat) (occ : List Bool) : ReifM REntry := do
    let pv ← lookupREntryPos! v
    if n == 0 then
      return v
    if n == 1 then
      return ← validOfEtaExpand1At v occ
    let (_, .addEntry re) ← newChkStep (.ca (.validOfEtaExpandNAt pv n occ)) .none
      | throwError "validOfEtaExpandNAt :: Unexpected evaluation result"
    return re

  def validOfEtaReduceNAt (v : REntry) (n : Nat) (occ : List Bool) : ReifM REntry := do
    let pv ← lookupREntryPos! v
    if n == 0 then
      return v
    if n == 1 then
      return ← validOfEtaReduce1At v occ
    let (_, .addEntry re) ← newChkStep (.ca (.validOfEtaReduceNAt pv n occ)) .none
      | throwError "validOfEtaReduceNAt :: Unexpected evaluation result"
    return re

  def validOfEtaExpandAt (v : REntry) (occ : List Bool) : ReifM REntry := do
    let .valid _ t := v
      | throwError "validOfEtaExpandAt :: Unexpected entry {v}"
    let .some (rty, _) := LamTerm.getPosWith occ (.base .prop) t
      | throwError "validOfEtaExpandAt :: {occ} is not a valid position of {t}"
    let n := rty.getArgTys.length
    validOfEtaExpandNAt v n occ

  def validOfEtaReduceAt (v : REntry) (occ : List Bool) : ReifM REntry := do
    let .valid _ t := v
      | throwError "validOfEtaReduceAt :: Unexpected entry {v}"
    let .some tocc := LamTerm.getPos occ t
      | throwError "validOfEtaReduceAt :: {occ} is not a valid position of {t}"
    let n := tocc.getLamTys.length
    validOfEtaReduceNAt v n occ

  def validOfExtensionalizeEqAt (v : REntry) (occ : List Bool) : ReifM REntry := do
    let pv ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.ca (.validOfExtensionalizeEqAt pv occ)) .none
      | throwError "validOfExtensionalizeEqAt :: Unexpected evaluation result"
    return re

  def validOfExtensionalizeEqFNAt (v : REntry) (n : Nat) (occ : List Bool) : ReifM REntry := do
    let pv ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.ca (.validOfExtensionalizeEqFNAt pv n occ)) .none
      | throwError "validOfExtensionalizeEqFNAt :: Unexpected evaluation result"
    return re

  def validOfIntensionalizeEqAt (v : REntry) (occ : List Bool) : ReifM REntry := do
    let pv ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.ca (.validOfIntensionalizeEqAt pv occ)) .none
      | throwError "validOfIntensionalizeEqAt :: Unexpected evaluation result"
    return re

  def validOfBVarLower (v : REntry) (n : REntry) : ReifM REntry := do
    let pv ← lookupREntryPos! v
    let pn ← lookupREntryPos! n
    let (_, .addEntry re) ← newChkStep (.i (.validOfBVarLower pv pn)) .none
      | throwError "validOfBVarLower :: Unexpected evaluation result"
    return re

  def validOfBVarLowers (v : REntry) (ns : Array REntry) : ReifM REntry := do
    let pv ← lookupREntryPos! v
    let pns ← ns.mapM lookupREntryPos!
    let (_, .addEntry re) ← newChkStep (.i (.validOfBVarLowers pv pns.data)) .none
      | throwError "validOfBVarLowers :: Unexpected evaluation result"
    return re

  /--
    Given `∀ (_ : s₀) (_ : s₁) ⋯ (_ : sₖ₋₁), body` and the fact
      that `s₀, s₁, ⋯, sₖ₋₁` are nonempty, return a proof of `body`
  -/
  def validOfElimForalls (v : REntry) (ns : Array REntry) : ReifM REntry := do
    let introed ← validOfIntros v ns.size
    validOfBVarLowers introed ns.reverse

  def validOfImp (v₁₂ : REntry) (v₁ : REntry) : ReifM REntry := do
    let p₁₂ ← lookupREntryPos! v₁₂
    let p₁ ← lookupREntryPos! v₁
    let (_, .addEntry re) ← newChkStep (.i (.validOfImp p₁₂ p₁)) .none
      | throwError "validOfImp :: Unexpected evaluation result"
    return re

  def validOfImps (impV : REntry) (hypVs : Array REntry) : ReifM REntry := do
    let imp ← lookupREntryPos! impV
    let ps ← hypVs.mapM lookupREntryPos!
    let (_, .addEntry re) ← newChkStep (.i (.validOfImps imp ps.data)) .none
      | throwError "validOfImps :: Unexpected evaluation result"
    return re

  /-- Repeated instantiation -/
  def validOfInstantiate (v : REntry) (args : Array LamTerm) : ReifM REntry := do
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.i (.validOfInstantiate p args.data)) .none
      | throwError "validOfInstantiate :: Unexpected evaluation result"
    return re

  def validOfInstantiateRev (v : REntry) (args : Array LamTerm) : ReifM REntry := do
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.i (.validOfInstantiateRev p args.data)) .none
      | throwError "validOfInstantiateRev :: Unexpected evaluation result"
    return re

  /--
    Given `∀ x₀ x₁ ⋯ xₖ₋₁, p` and `arg₀, arg₁, ⋯, argₖ₋₁`, return
      `p[x₀/arg₀, x₁/arg₁, ⋯, xₖ₋₁/argₖ₋₁]`
  -/
  def validOfInstantiateForall (v : REntry) (args : Array LamTerm) : ReifM REntry := do
    if args.size == 0 then
      return v
    let v ← validOfIntros v args.size
    validOfInstantiateRev v args

  def validOfAndLeft (v : REntry) (occ : List Bool) : ReifM REntry := do
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.i (.validOfAndLeft p occ)) .none
      | throwError "validOfAndLeft :: Unexpected evaluation result"
    return re

  def validOfAndRight (v : REntry) (occ : List Bool) : ReifM REntry := do
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.i (.validOfAndRight p occ)) .none
      | throwError "validOfAndRight :: Unexpected evaluation result"
    return re

  /-- Exhaustively decompose `∧` at position `occ` -/
  partial def decomposeAnd (v : REntry) (occ : List Bool) : ReifM (Array REntry) := do
    let .valid _ t := v
      | throwError "decomposeAnd :: Unexpected entry"
    if !(t.isSign true occ) then throwError "decomposeAnd :: {occ} is not a positive position of {t}"
    let .some sub := t.getPos occ
      | throwError "decomposeAnd :: Unexpected error"
    if sub.getAppFn == .base .and && sub.getAppArgs.length == 2 then
      let left ← validOfAndLeft v occ
      let right ← validOfAndRight v occ
      return (← decomposeAnd left occ).append (← decomposeAnd right occ)
    else
      return #[v]

  def boolFacts : ReifM REntry := do
    let (_, .addEntry re) ← newChkStep (.f .boolFacts) .none
      | throwError "boolFacts :: Unexpected evaluation result"
    return re

  def iteSpec (s : LamSort) : ReifM REntry := do
    let (_, .addEntry re) ← newChkStep (.f (.iteSpec s)) .none
      | throwError "iteSpec :: Unexpected evaluation result"
    return re

  def skolemize (exV : REntry) : ReifM REntry := do
    let eidx ← getMaxEVarSucc
    let ex ← lookupREntryPos! exV
    let (new?, .newEtomWithValid _ lctx t) ← newChkStep (.e (.skolemize ex)) .none
      | throwError "skolemize :: Unexpected evaluation result"
    if new? then
      let _ ← nonemptyOfEtom eidx
    return .valid lctx t

  -- TODO: To be replaced by complete clausification
  def skolemizeMostIntoForall (exV : REntry) : ReifM REntry := do
    let mut exV := exV
    while true do
      let .valid _ t := exV
        | throwError "skolemizeMostIntoForall :: Unexpected entry {exV}"
      if t.isMkForallE then
        exV ← validOfIntroMost exV
      let .valid _ t := exV
        | throwError "skolemizeMostIntoForall :: Unexpected entry {exV}"
      if t.isMkExistE then
        exV ← skolemize exV
        exV ← validOfHnf exV
      else
        break
    return exV

  def define (t : LamTerm) : ReifM REntry := do
    let eidx ← getMaxEVarSucc
    let (new?, .newEtomWithValid _ [] t) ← newChkStep (.e (.define t)) .none
      | throwError "define :: Unexpected evaluation result"
    if new? then
      let _ ← nonemptyOfEtom eidx
    return .valid [] t

  def validOfPrepConv (pc : PrepConvStep) (v : REntry) (occ : List Bool) : ReifM REntry := do
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.p pc p occ) .none
      | throwError "validOfPrepConv :: Unexpected evaluation result"
    return re

end Checker

section CheckerUtils

  /--
    `.bvar i` will be turned into `.bvar map[i]`
    It is required that the size of `rmap` is equal to the length of local context
  -/
  def reorderLCtx (v : REntry) (rmap : Array Nat) : ReifM REntry := do
    let .valid lctx _ := v
      | throwError "reorderLCtx :: Unexpected entry {v}"
    let lsize := lctx.length
    if rmap.size != lsize then
      throwError "reorderLCtx :: Length of lctx does not equal size of reorder map"
    let mut ex : Array LamSort := rmap.map (fun _ => .atom 0)
    let mut argBVarIdx : Array Nat := #[]
    for (s, i) in (Array.mk lctx).zipWithIndex do
      let .some i' := rmap[i]?
        | throwError "reorderLCtx :: Does not know where does `.bvar i` map to"
      if i' >= lsize then
        throwError "reorderLCtx :: Index {i'} out of bound {lsize}"
      ex := ex.set! i' s
      argBVarIdx := argBVarIdx.push (lsize - i - 1 + i')
    let v ← validOfAppend v ex
    validOfInstantiate v (argBVarIdx.map LamTerm.bvar)

  /-- Refer to docstring of `LamTerm.isGeneral` -/
  def toDefinition? (v : REntry) : ReifM (Option REntry) := do
    let .valid lctx t := v
      | throwError "toDefinition :: Unexpected entry {v}"
    let mut introed := t.betaReduceHacky
    let mut lctx' := lctx
    while true do
      match introed.intro1? with
      | .some (s, i) => introed := i; lctx' := s :: lctx'
      | .none => break
    let .app _ (.app _ (.base head) lhs) rhs := introed
      | return .none
    if !head.isEq && !(head == .iff) then
      return .none
    let ml := lhs.getLamBody.isGeneral (lctx'.length + lhs.getLamTys.length)
    let mr := rhs.getLamBody.isGeneral (lctx'.length + rhs.getLamTys.length)
    if ml.isNone && mr.isNone then return .none
    let .some m := ml <|> mr
      | throwError "toDefinition? :: Unexpected error"
    let v ← validOfBetaReduce v
    let v ← validOfIntroMost v
    let v ← (do if (head == .iff) then validOfPrepConv .validOfPropext v [] else pure v)
    let v ← (do if ml.isNone then validOfEqSymm v else pure v)
    let v ← validOfExtensionalizeEqFNAt v (m.size - lctx'.length) []
    let v ← validOfBetaReduce v
    let v ← validOfIntros v (m.size - lctx'.length)
    let v ← reorderLCtx v m
    let v ← validOfRevertAll v
    let v ← validOfIntensionalizeEqAt v []
    let v ← validOfEtaReduceNAt v m.size [false, true]
    return .some v

  /--
    Recognize all definitions-like facts within `vs`, exhaustively
      rewrite using them and remove them in the end
    Meanwhile, all λterms in the `ts` are rewritten using the
      recognied definitions
  -/
  def recognizeDefsAndUnfold
    (vs : Array REntry) (minds : Array MutualIndInfo) :
    ReifM (Array REntry × Array MutualIndInfo) := do
    let mut active := vs.reverse
    let mut passive := #[]
    let mut minds := minds
    while true do
      let .some back := active.back?
        | break
      active := active.pop
      let .some v' ← toDefinition? back
        | passive := passive.push back; continue
      trace[auto.lamReif.prep.def] "Entry {back} is def-like and is turned into {v'}"
      let .valid [] rw@(.app _ (.app _ (.base (.eq _)) lhs) rhs) := v'
        | throwError "recognizeDefsAndUnfold :: Unexpected definition entry {v'}"
      -- If the left-hand-side occurs inside the right-hand-side,
      --   then this definition is recursive and we will not unfold it
      if rhs.abstractsImp #[lhs] != rhs then
        passive := passive.push back; continue
      passive ← passive.mapM (validOfMpAll · v')
      active ← active.mapM (validOfMpAll · v')
      minds ← minds.mapM (fun mind => do
        let .some mind := mind.mpAll? rw
          | throwError "recognizeDefsAndUnfold :: Unexpected error"
        return mind)
    return (passive, minds)

  register_option auto.lamReif.prep.def : Bool := {
    defValue := true
    descr := "Recognize and unfold definitions"
  }

  def preprocess
    (vs : Array REntry) (minds : Array MutualIndInfo) :
    ReifM (Array REntry × Array MutualIndInfo) := do
    let vs ← vs.mapM validOfBetaReduce
    let vs ← vs.mapM skolemizeMostIntoForall
    let vs ← vs.mapM validOfExtensionalize
    let vs ← vs.mapM validOfBetaReduce
    let (vs, minds) ← (do
      if auto.lamReif.prep.def.get (← getOptions) then
        recognizeDefsAndUnfold vs minds
      else
        return (vs, minds))
    let vs ← vs.mapM validOfBetaReduce
    let vs ← vs.mapM (fun re => validOfPrepConv .validOfPushBVCast re [])
    let vs ← vs.mapM validOfRevertAll
    for v in vs do
      trace[auto.lamReif.prep.printResult] "{v}"
    for mind in minds do
      let smind := String.intercalate "\n" ("" :: mind.map toString)
      trace[auto.lamReif.prep.printResult] "{smind}"
    return (vs, minds)

  def auxLemmas (vs : Array REntry) : ReifM (Array REntry) := do
    let mut ret := #[]
    -- Boolean facts
    if vs.any (fun re => re.containsSort (.base .bool)) then
      let factsConj ← boolFacts
      ret := ret.append (← decomposeAnd factsConj [])
    -- ite specification
    let allLamTerms := (vs.map (fun re => Array.mk (REntry.allLamTerms re))).concatMap id
    let iteSorts := LamExportUtils.collectLamTermsIteSorts allLamTerms
    ret := ret.append (← iteSorts.toArray.mapM iteSpec)
    return ret

end CheckerUtils

/--
  Accept a new expression representing λterm atom
  Returns the index of it in the `varVal` array
-/
def newTermExprAux (e : Expr) (sort : LamSort) : ReifM LamTerm := do
  let varMap ← getVarMap
  let varVal ← getVarVal
  let idx := varVal.size
  setVarVal (varVal.push (e, sort))
  setVarMap (varMap.insert e idx)
  let _ ← nonemptyOfAtom idx
  return .atom idx

def newTypeExpr (e : Expr) : ReifM LamSort := do
  let tyVarMap ← getTyVarMap
  let tyVal ← getTyVal
  let idx := tyVal.size
  -- The universe level of `e`
  let origSort ← Meta.inferType e
  let origSort := (← instantiateMVars origSort).headBeta
  let .sort lvl := origSort
    | throwError "newTypeExpr :: Unexpected sort {origSort}"
  setTyVal (tyVal.push (e, lvl))
  setTyVarMap (tyVarMap.insert e idx)
  return .atom idx

def processTypeExpr (e : Expr) : ReifM LamSort := do
  let tyVarMap ← getTyVarMap
  let e ← Reif.resolveTy e
  if let .some idx := tyVarMap.find? e then
    return .atom idx
  match e with
  | .sort lvl =>
    if ← Meta.isLevelDefEq lvl .zero then
      return .base .prop
    else
      newTypeExpr e
  | .const ``Bool [] => return .base .bool
  | .const ``Nat [] => return .base .nat
  | .const ``Int [] => return .base .int
  | .const ``String [] => return .base .string
  | .const ``Empty [] => return .base .empty
  | .app (.const ``BitVec []) nExpr =>
    if let .some n ← @id (MetaM _) (Meta.evalNat nExpr) then
      return .base (.bv n)
    else
      newTypeExpr e
  | _ => newTypeExpr e

-- At this point, there should only be non-dependent `∀`s in the type.
private def reifTypeAux : Expr → ReifM LamSort
| .mdata _ e => reifTypeAux e
| e@(.forallE _ ty body _) => do
  if body.hasLooseBVar 0 then
    processTypeExpr e
  else
    return .func (← reifTypeAux ty) (← reifTypeAux body)
| e => processTypeExpr e

def reifType (e : Expr) : ReifM LamSort := do
  let e ← prepReduceExpr e
  reifTypeAux e

def newTermExpr (e : Expr) : ReifM LamTerm := do
  let eTy ← instantiateMVars (← Meta.inferType e)
  let lamTy ← reifType eTy
  newTermExprAux e lamTy

def reifMapIL : HashMap Name (LamSort → LamBaseTerm) :=
  HashMap.ofList [
    (``Eq,                .eq),
    (``Embedding.forallF, .forallE),
    (``Exists,            .existE),
    (``Bool.ite',         .ite)
  ]

def reifMapConstNilLvl : HashMap Name LamTerm :=
  HashMap.ofList [
    (``True,              .base .trueE),
    (``False,             .base .falseE),
    (``Not,               .base .not),
    (``And,               .base .and),
    (``Or,                .base .or),
    (``Iff,               .base .iff),
    (``Bool.ofProp,       .base .ofProp),
    (``true,              .base .trueb),
    (``false,             .base .falseb),
    (``not,               .base .notb),
    (``and,               .base .andb),
    (``or,                .base .orb),
    (``Nat.zero,          .base (.natVal 0)),
    (``Nat.succ,          .lam (.base .nat) (.mkNatBinOp .nadd (.bvar 0) (.base (.natVal 1)))),
    (``Nat.add,           .base .nadd),
    (``Nat.sub,           .base .nsub),
    (``Nat.mul,           .base .nmul),
    (``Nat.div,           .base .ndiv),
    (``Nat.mod,           .base .nmod),
    (``Nat.le,            .base .nle),
    (``Nat.lt,            .base .nlt),
    (`Nat.ModEq,          .nmodeq),
    (``Int.ofNat,         .base .iofNat),
    (``Int.negSucc,       .base .inegSucc),
    (``Int.neg,           .base .ineg),
    (``Int.add,           .base .iadd),
    (``Int.sub,           .base .isub),
    (``Int.mul,           .base .imul),
    (``Int.div,           .base .idiv),
    (``Int.mod,           .base .imod),
    (``Int.ediv,          .base .iediv),
    (``Int.emod,          .base .iemod),
    (``Int.le,            .base .ile),
    (``Int.lt,            .base .ilt),
    (`Int.ModEq,          .imodeq),
    (``String.length,     .base .slength),
    (``String.append,     .base .sapp),
    (``String.isPrefixOf, .base .sprefixof),
    (``String.replace,    .base .srepall)
  ]

def reifMapBVConst1 : HashMap Name (Nat → LamTerm) :=
  HashMap.ofList [
    (``BitVec.ofNat,       fun n => .base (.bvofNat n)),
    (``BitVec.toNat,       fun n => .base (.bvtoNat n)),
    (``BitVec.ofInt,       fun n => .base (.bvofInt n)),
    (``BitVec.toInt,       fun n => .base (.bvtoInt n)),
    (``BitVec.msb,         fun n => .base (.bvmsb n)),
    (``BitVec.add,         fun n => .base (.bvadd n)),
    (``BitVec.sub,         fun n => .base (.bvsub n)),
    (``BitVec.neg,         fun n => .base (.bvneg n)),
    (``BitVec.abs,         fun n => .base (.bvabs n)),
    (``BitVec.mul,         fun n => .base (.bvmul n)),
    (``BitVec.smtUDiv,     fun n => .base (.bvudiv n)),
    (``BitVec.umod,        fun n => .base (.bvurem n)),
    (``BitVec.smtSDiv,     fun n => .base (.bvsdiv n)),
    (``BitVec.srem,        fun n => .base (.bvsrem n)),
    (``BitVec.smod,        fun n => .base (.bvsmod n)),
    (``BitVec.ult,         fun n => .base (.bvult n)),
    (``BitVec.ule,         fun n => .base (.bvule n)),
    (``BitVec.slt,         fun n => .base (.bvslt n)),
    (``BitVec.sle,         fun n => .base (.bvsle n)),
    (``BitVec.and,         fun n => .base (.bvand n)),
    (``BitVec.or,          fun n => .base (.bvor n)),
    (``BitVec.xor,         fun n => .base (.bvxor n)),
    (``BitVec.not,         fun n => .base (.bvnot n)),
    (``BitVec.shiftLeft,   fun n => .base (.bvshl n)),
    (``BitVec.ushiftRight, fun n => .base (.bvlshr n)),
    (``BitVec.sshiftRight, fun n => .base (.bvashr n)),
    (``BitVec.rotateLeft,  fun n => .bvrotateLeft n),
    (``BitVec.rotateRight, fun n => .bvrotateRight n)
  ]

def reifMapBVConst2 : HashMap Name (Nat → Nat → LamTerm) :=
  HashMap.ofList [
    (``BitVec.append,     fun n m => .base (.bvappend n m)),
    (``BitVec.replicate,  fun w i => .base (.bvrepeat w i)),
    (``BitVec.zeroExtend, fun w v => .base (.bvzeroExtend w v)),
    (``BitVec.signExtend, fun w v => .base (.bvsignExtend w v))
  ]

def reifMapBVConst3 : HashMap Name (Nat → Nat → Nat → LamTerm) :=
  HashMap.ofList [
    (``BitVec.extractLsb, fun n h l => .base (.bvextract n h l))
  ]

def reifMapAttributesProp : HashMap Name String :=
  HashMap.ofList [
    (``SMT.Attribute.trigger, "pattern")
  ]

def processSimpleLit (l : Literal) : LamTerm :=
  match l with
  | .natVal n => .base (.natVal n)
  | .strVal s => .base (.strVal s)

def processSimpleConst (name : Name) (lvls : List Level) : ReifM (Option LamTerm) := do
  if let .some t := reifMapConstNilLvl.find? name then
    if lvls.length != 0 then
      throwError "processSimpleConst :: ConstNilLvl constants should have nil level list"
    return t
  if name == ``Embedding.ImpF then
    let [u, v] := lvls
      | throwError "processSimpleConst :: Invalid levels {lvls} for Auto.Embedding.ImpF"
    if (← Meta.isLevelDefEq u .zero) ∧ (← Meta.isLevelDefEq v .zero) then
      return .some (.base .imp)
    else
      throwError "processSimpleConst :: Non-propositional implication is not supported"
  return .none

def processSimpleApp (fn arg : Expr) : ReifM (Option LamTerm) := do
  let args := fn.getAppArgs ++ #[arg]
  let fn := fn.getAppFn
  let .const name lvls := fn
    | return .none
  match args.data with
  | [] => throwError "processSimpleApp :: Unexpected error"
  | [arg] =>
    if let .some tcon := reifMapBVConst1.find? name then
      if lvls.length != 0 then
        throwError "processSimpleApp :: BVConst1 should have nil level list"
      if let .some n ← @id (MetaM _) (Meta.evalNat arg) then
        return .some (tcon n)
      return .none
    if let .some attrName := reifMapAttributesProp.find? name then
      if lvls.length != 1 then
        throwError "processSimpleApp :: Attribute should have one level"
      return .some (.base (.ocst (.smtAttr1T attrName (← reifType arg) (.base .prop))))
      -- `arg` is the original (un-lifted) type
    if let .some tcon := reifMapIL.find? name then
      return .some (.base (tcon (← reifType arg)))
    return .none
  | [arg₁, arg₂] =>
    if let .some tcon := reifMapBVConst2.find? name then
      if lvls.length != 0 then
        throwError "processSimpleApp :: BVConst2 should have nil level list"
      match ← @id (MetaM _) (Meta.evalNat arg₁),
            ← @id (MetaM _) (Meta.evalNat arg₂) with
      | .some n, .some m => return .some (tcon n m)
      | _,       _       => return .none
    return .none
  | [arg₁, arg₂, arg₃] =>
    if let .some tcon := reifMapBVConst3.find? name then
      if lvls.length != 0 then
        throwError "processSimpleApp :: BVConst2 should have nil level list"
      match ← @id (MetaM _) (Meta.evalNat arg₁),
            ← @id (MetaM _) (Meta.evalNat arg₂),
            ← @id (MetaM _) (Meta.evalNat arg₃) with
      | .some n, .some h, .some l => return .some (tcon n h l)
      | _,       _,       _       => return .none
    return .none
  | _ => return .none

open LamCstrD in
/--
  fn   : .const _ _
  arg₁ : .const _ _
-/
def reifMapLam0Arg2NoLit : HashMap (Name × Name) (Expr × LamTerm) :=
  HashMap.ofList [
    ((``NatCast.natCast, ``Int), (.const ``Int.ofNat [], .base .iofNat)),
    ((``Neg.neg, ``Int),         (.const ``Int.neg [], .base .ineg)),
    ((`Abs.abs, ``Int),          (.const ``Int.abs [], .base .iabs)),
    ((``LE.le, ``Nat),           (.const ``Nat.le [], .base .nle)),
    ((``LE.le, ``Int),           (.const ``Int.le [], .base .ile)),
    ((``LE.le, ``String),        (.const ``String.le [], .base .sle)),
    ((``GE.ge, ``Nat),           (.const ``Nat.ge [], .nge)),
    ((``GE.ge, ``Int),           (.const ``Int.ge [], .ige)),
    ((``GE.ge, ``String),        (.const ``String.ge [], .sge)),
    ((``LT.lt, ``Nat),           (.const ``Nat.lt [], .base .nlt)),
    ((``LT.lt, ``Int),           (.const ``Int.lt [], .base .ilt)),
    ((``LT.lt, ``String),        (.const ``String.lt [], .base .slt)),
    ((``GT.gt, ``Nat),           (.const ``Nat.gt [], .ngt)),
    ((``GT.gt, ``Int),           (.const ``Int.gt [], .igt)),
    ((``GT.gt, ``String),        (.const ``String.gt [], .sgt)),
    ((``Max.max, ``Nat),         (.const ``Nat.max [], .base .nmax)),
    ((``Max.max, ``Int),         (.const ``Int.max [], .base .imax)),
    ((``Min.min, ``Nat),         (.const ``Nat.min [], .base .nmin)),
    ((``Min.min, ``Int),         (.const ``Int.min [], .base .imin))
  ]

open LamCstrD in
/--
  fn   : .const _ _
  arg₁ : .app (.const _ _) natlit
-/
def reifMapLam0Arg2Natlit : HashMap (Name × Name) (Array ((Nat → Expr) × (Nat → LamTerm))) :=
  HashMap.ofList [
    ((``Neg.neg, ``BitVec),
              #[(fun n => .app (.const ``BitVec.neg []) (.lit (.natVal n)), fun n => .base (.bvneg n))]),
    ((`Abs.abs, ``BitVec),
              #[(fun n => .app (.const ``BitVec.abs []) (.lit (.natVal n)), fun n => .base (.bvabs n))]),
    ((``Complement.complement, ``BitVec),
              #[(fun n => .app (.const ``BitVec.not []) (.lit (.natVal n)), fun n => .base (.bvnot n))]),
    ((``LE.le, ``BitVec),
              #[(fun n => .app (.const ``BitVec.propule []) (.lit (.natVal n)), fun n => .base (.bvpropule n)),
                (fun n => .app (.const ``BitVec.propsle []) (.lit (.natVal n)), fun n => .base (.bvpropsle n))]),
    ((``GE.ge, ``BitVec),
              #[(fun n => .app (.const ``BitVec.propuge []) (.lit (.natVal n)), fun n => .bvpropuge n),
                (fun n => .app (.const ``BitVec.propsge []) (.lit (.natVal n)), fun n => .bvpropsge n)]),
    ((``LT.lt, ``BitVec),
              #[(fun n => .app (.const ``BitVec.propult []) (.lit (.natVal n)), fun n => .base (.bvpropult n)),
                (fun n => .app (.const ``BitVec.propslt []) (.lit (.natVal n)), fun n => .base (.bvpropslt n))]),
    ((``GT.gt, ``BitVec),
              #[(fun n => .app (.const ``BitVec.propugt []) (.lit (.natVal n)), fun n => .bvpropugt n),
                (fun n => .app (.const ``BitVec.propsgt []) (.lit (.natVal n)), fun n => .bvpropsgt n)])
  ]

/--
  fn   : .const _ _
  arg₁ : .const _ _
  arg₂ : .const _ _
-/
def reifMapLam0Arg4NoLit : HashMap (Name × Name × Name) (Expr × LamTerm) :=
  HashMap.ofList [
    ((``HAdd.hAdd, ``Nat, ``Nat),             (.const ``Nat.add [], .base .nadd)),
    ((``HAdd.hAdd, ``Int, ``Int),             (.const ``Int.add [], .base .iadd)),
    ((``HSub.hSub, ``Nat, ``Nat),             (.const ``Nat.sub [], .base .nsub)),
    ((``HSub.hSub, ``Int, ``Int),             (.const ``Int.sub [], .base .isub)),
    ((``HMul.hMul, ``Nat, ``Nat),             (.const ``Nat.mul [], .base .nmul)),
    ((``HMul.hMul, ``Int, ``Int),             (.const ``Int.mul [], .base .imul)),
    ((``HDiv.hDiv, ``Nat, ``Nat),             (.const ``Nat.div [], .base .ndiv)),
    ((``HDiv.hDiv, ``Int, ``Int),             (.const ``Int.div [], .base .idiv)),
    ((``HAppend.hAppend, ``String, ``String), (.const ``String.append [], .base .sapp))
  ]

/--
  fn   : .const _ _
  arg₁ : .app (.const _ _) natlit₁
  arg₂ : .app (.const _ _) natlit₂
  |- natlit₁ = natlit₂
-/
def reifMapLam0Arg4NatLitNatLitEq : HashMap (Name × Name) (Array ((Nat → Expr) × (Nat → LamTerm))) :=
  HashMap.ofList [
    ((``HAdd.hAdd, ``BitVec),
      #[(fun n => .app (.const ``BitVec.add []) (.lit (.natVal n)), fun n => .base (.bvadd n))]),
    ((``HSub.hSub, ``BitVec),
      #[(fun n => .app (.const ``BitVec.sub []) (.lit (.natVal n)), fun n => .base (.bvsub n))]),
    ((``HMul.hMul, ``BitVec),
      #[(fun n => .app (.const ``BitVec.mul []) (.lit (.natVal n)), fun n => .base (.bvmul n))]),
    ((``HDiv.hDiv, ``BitVec),
      #[(fun n => .app (.const ``BitVec.smtUDiv []) (.lit (.natVal n)), fun n => .base (.bvudiv n)),
        (fun n => .app (.const ``BitVec.smtSDiv []) (.lit (.natVal n)), fun n => .base (.bvsdiv n))]),
    ((``HAnd.hAnd, ``BitVec),
      #[(fun n => .app (.const ``BitVec.and []) (.lit (.natVal n)), fun n => .base (.bvand n))]),
    ((``HOr.hOr, ``BitVec),
      #[(fun n => .app (.const ``BitVec.or []) (.lit (.natVal n)), fun n => .base (.bvor n))]),
    ((``HXor.hXor, ``BitVec),
      #[(fun n => .app (.const ``BitVec.xor []) (.lit (.natVal n)), fun n => .base (.bvxor n))])
  ]

open LamCstrD in
/--
  fn   : .const _ _
  arg₁ : .app (.const _ _) natlit₁
  arg₂ : .app (.const _ _) natlit₂
  |- natlit₁ ?? natlit₂
-/
def reifMapLam0Arg4NatLitNatLitH : HashMap (Name × Name) (Array ((Nat → Nat → Expr) × (Nat → Nat → LamTerm))) :=
  HashMap.ofList [
    ((``HAppend.hAppend, ``BitVec),
      #[(fun n m => mkApp2 (.const ``BitVec.append []) (.lit (.natVal n)) (.lit (.natVal m)), fun n m => .base (.bvappend n m))]),
    ((``HShiftLeft.hShiftLeft, ``BitVec),
      #[(fun n m => mkApp2 (.const ``BitVec.smtHshiftLeft []) (.lit (.natVal n)) (.lit (.natVal m)), fun n m => .bvsmtHshl n m)]),
    ((``HShiftRight.hShiftRight, ``BitVec),
      #[(fun n m => mkApp2 (.const ``BitVec.smtHushiftRight []) (.lit (.natVal n)) (.lit (.natVal m)), fun n m => .bvsmtHlshr n m),
        (fun n m => mkApp2 (.const ``BitVec.smtHsshiftRight []) (.lit (.natVal n)) (.lit (.natVal m)), fun n m => .bvsmtHashr n m)])
  ]

/--
  fn   : .const _ _
  arg₁ : .app (.const _ _) natlit
  arg₂ : .const _ _
-/
def reifMapLam0Arg4NatLit : HashMap (Name × Name) (Array ((Nat → Expr) × (Nat → LamTerm))) :=
  HashMap.ofList [
    ((``HShiftLeft.hShiftLeft, ``BitVec),
      #[(fun n => .app (.const ``BitVec.shiftLeft []) (.lit (.natVal n)), fun n => .base (.bvshl n))]),
    ((``HShiftRight.hShiftRight, ``BitVec),
      #[(fun n => .app (.const ``BitVec.ushiftRight []) (.lit (.natVal n)), fun n => .base (.bvlshr n)),
        (fun n => .app (.const ``BitVec.sshiftRight []) (.lit (.natVal n)), fun n => .base (.bvashr n))])
  ]

def processLam0Arg2 (e fn arg₁ arg₂ : Expr) : MetaM (Option LamTerm) := do
  let .const fnName _ := fn
    | return .none
  if arg₁.isConst then
    let .const arg₁Name _ := arg₁
      | throwError "processLam0Arg2 :: Unexpected error"
    if let .some (e', t) := reifMapLam0Arg2NoLit.find? (fnName, arg₁Name) then
      if (← Meta.isDefEqD e e') then
        return .some t
  if arg₁.isApp then
    let .app arg₁fn arg₁arg := arg₁
      | throwError "processLam0Arg2 :: Unexpected error"
    if let .const arg₁FnName _ := arg₁fn then
      if let .some candidates := reifMapLam0Arg2Natlit.find? (fnName, arg₁FnName) then
        if let .some n ← Meta.evalNat arg₁arg then
          for (e'con, tcon) in candidates do
            if (← Meta.isDefEqD e (e'con n)) then
              return .some (tcon n)
  return .none

def processLam0Arg3 (e fn arg₁ arg₂ arg₃ : Expr) : MetaM (Option LamTerm) := do
  match fn with
  | .const ``OfNat.ofNat _ =>
    match arg₁ with
    | .const ``Nat _ =>
      if (← Meta.isDefEqD e arg₂) then
        let .lit (.natVal nv) := arg₂
          | throwError "processLam0Arg3 :: OfNat.ofNat instance is not based on a nat literal"
        return .some (.base (.natVal nv))
      return .none
    | .const ``Int _ =>
      if (← Meta.isDefEqD e (.app (.const ``Int.ofNat []) arg₂)) then
        let .lit (.natVal nv) := arg₂
          | throwError "processLam0Arg3 :: OfNat.ofNat instance is not based on a nat literal"
        return .some (.mkIOfNat (.base (.natVal nv)))
      return .none
    | .app (.const ``BitVec []) nExpr =>
      if let .some n ← Meta.evalNat nExpr then
        if (← Meta.isDefEqD e (mkApp2 (.const ``BitVec.ofNat []) (.lit (.natVal n)) arg₂)) then
          let .lit (.natVal nv) := arg₂
            | throwError "processLam0Arg3 :: OfNat.ofNat instance is not based on a nat literal"
          return .some (.base (.bvVal n nv))
      return .none
    | _ => return .none
  | _ => return .none

def processLam0Arg4 (e fn arg₁ arg₂ arg₃ arg₄ : Expr) : MetaM (Option LamTerm) := do
  let .const fnName _ := fn
    | return .none
  if arg₁.isConst && arg₂.isConst then
    let .const arg₁name _ := arg₁
      | throwError "processLam0Arg4 :: Unexpected error"
    let .const arg₂name _ := arg₂
      | throwError "processLam0Arg4 :: Unexpected error"
    if let .some (e', t) := reifMapLam0Arg4NoLit.find? (fnName, arg₁name, arg₂name) then
      if (← Meta.isDefEqD e e') then
        return .some t
      return .none
  if arg₁.isApp && arg₂.isConst then
    let .app arg₁fn arg₁arg := arg₁
      | throwError "processLam0Arg4 :: Unexpected error"
    if arg₁fn.isConst then
      let .const arg₁fnName _ := arg₁fn
        | throwError "processLam0Arg4 :: Unexpected error {arg₁fn}"
      if let .some candidates := reifMapLam0Arg4NatLit.find? (fnName, arg₁fnName) then
        for (e'con, tcon) in candidates do
          if let .some n ← Meta.evalNat arg₁arg then
            if (← Meta.isDefEqD e (e'con n)) then
              return tcon n
  if arg₁.isApp && arg₂.isApp then
    let .app arg₁fn arg₁arg := arg₁
      | throwError "processLam0Arg4 :: Unexpected error"
    let .app arg₂fn arg₂arg := arg₂
      | throwError "processLam0Arg4 :: Unexpected error"
    if arg₁fn.isConst && arg₂fn.isConst then
      let .const arg₁fnName _ := arg₁fn
        | throwError "processLam0Arg4 :: Unexpected error"
      if let .some candidates := reifMapLam0Arg4NatLitNatLitEq.find? (fnName, arg₁fnName) then
        for (e'con, tcon) in candidates do
          if let .some n ← Meta.evalNat arg₁arg then
            if (← Meta.isDefEqD e (e'con n)) then
              return tcon n
      if let .some candidates := reifMapLam0Arg4NatLitNatLitH.find? (fnName, arg₁fnName) then
        for (e'con, tcon) in candidates do
          match ← Meta.evalNat arg₁arg, ← Meta.evalNat arg₂arg with
          | .some n , .some m =>
            if (← Meta.isDefEqD e (e'con n m)) then
              return .some (tcon n m)
            return .none
          | _,        _       => return .none
  return .none

def processComplexTermExpr (e : Expr) : MetaM (Option LamTerm) := do
  let e := Expr.eta e
  let lams := (Expr.lambdaBinders e).size
  match lams with
  | 0 =>
    let fn := e.getAppFn
    let args := e.getAppArgs
    match args.data with
    | [] => return .none
    | [_] => return .none
    | [arg₁, arg₂] => processLam0Arg2 e fn arg₁ arg₂
    | [arg₁, arg₂, arg₃] => processLam0Arg3 e fn arg₁ arg₂ arg₃
    | [arg₁, arg₂, arg₃, arg₄] =>
      processLam0Arg4 e fn arg₁ arg₂ arg₃ arg₄
    | _ => return .none
  | _ => return .none

def processNewTermExpr (e : Expr) : ReifM LamTerm := do
  let e := e.eta
  match e with
  | .lit l => return processSimpleLit l
  | .const name lvls => do
    match ← processSimpleConst name lvls with
    | .some t => return t
    | .none => processOther e
  | .app fn arg => do
    match ← processSimpleApp fn arg with
    | .some t => return t
    | .none => processOther e
  | e => processOther e
where
  processOther (e : Expr) := do
    if let .some res ← processComplexTermExpr e then
      return res
    newTermExpr e

def processTermExpr (lctx : HashMap FVarId Nat) (e : Expr) : ReifM LamTerm := do
  if let .fvar fid := e then
    if let .some n := deBruijn? lctx fid then
      return .bvar n
  let e ← Reif.resolveVal e
  let varMap ← getVarMap
  -- If the expression has already been processed
  if let .some id := varMap.find? e then
    return .atom id
  -- If the expression has not been processed
  processNewTermExpr e
where
  deBruijn? (lctx : HashMap FVarId Nat) (id : FVarId) : Option Nat :=
    match lctx.find? id with
    | .some n => lctx.size - 1 - n
    | .none   => none

partial def reifTerm (lctx : HashMap FVarId Nat) : Expr → ReifM LamTerm
| .app fn arg => do
  let lamFn ← reifTerm lctx fn
  let lamArg ← reifTerm lctx arg
  let argTy ← Meta.inferType arg
  let lamTy ← reifType argTy
  return .app lamTy lamFn lamArg
| .lam name ty body binfo => do
  let lamTy ← reifType ty
  let body ← Meta.withLocalDecl name binfo ty fun fvar => do
    let body' := body.instantiate1 fvar
    reifTerm (lctx.insert fvar.fvarId! lctx.size) body'
  return .lam lamTy body
| e => processTermExpr lctx e

def reifTermCheckType (e : Expr) : ReifM (LamSort × LamTerm) := do
  let t ← reifTerm .empty e
  let ltv ← getLamTyValAtMeta
  let .some s := t.lamCheck? ltv Embedding.Lam.dfLCtxTy
    | throwError "reifTermCheckType :: LamTerm {t} is not type correct"
  return (s, t)

/-- Return the positions of the reified and `resolveImport`-ed facts within the `validTable` -/
def reifFacts (facts : Array UMonoFact) : ReifM (Array LamTerm) :=
  facts.mapM (fun ⟨proof, ty, deriv⟩ => do
    let (s, lamty) ← reifTermCheckType ty
    if s != .base .prop then
      throwError "reifFacts :: Fact {lamty} is not of type `prop`"
    trace[auto.lamReif.printResult] "Successfully reified proof of {← Meta.zetaReduce ty} to λterm `{lamty}`"
    newAssertion proof deriv lamty
    return lamty)

def reifInhabitations (inhs : Array UMonoFact) : ReifM (Array LamSort) :=
  inhs.mapM (fun ⟨inhTy, ty, deriv⟩ => do
    let s ← reifType ty
    newInhabitation inhTy deriv s
    trace[auto.lamReif.printResult] "Successfully reified inhabitation proof of {ty} to λsort `{s}`"
    return s)

def reifInd (ind : SimpleIndVal) : ReifM (Option IndInfo) := do
  let ⟨name, type, ctors, projs⟩ := ind
  if name == ``Nat || name == ``Int || name == ``Bool ||
     name == ``String || name == ``String.Pos || name == ``Empty ||
     name == ``BitVec then
    return .none
  -- For now, do not reify inductively defined proposition
  if ← isIndProp name then
    return .none
  let rty ← reifType type
  let rctors ← ctors.mapM (fun (e, _) => reifTermCheckType e)
  let rprojs ← projs.mapM (fun ps => ps.mapM reifTermCheckType)
  let ret := ⟨rty, rctors.data, rprojs.bind (·.data)⟩
  trace[auto.lamReif.printResult] "Successfully reified inductive info {← ind.zetaReduce} to {ret}"
  return .some ret

def reifMutInd (mind : Array SimpleIndVal) : ReifM (Option MutualIndInfo) := do
  let mut ret := #[]
  for ind in mind do
    let .some ii ← reifInd ind
      | return .none
    ret := ret.push ii
  return ret.data

def reifMutInds (minds : Array (Array SimpleIndVal)) : ReifM (Array MutualIndInfo) := do
  let mut ret := #[]
  for mind in minds do
    let .some mi ← reifMutInd mind
      | continue
    ret := ret.push mi
  return ret

partial def collectDerivFor (re : REntry) : ReifM DTr := do
  let proof ← lookupREntryProof! re
  match proof with
  | .chkStep cs =>
    let premises := cs.premises
    let branches ← premises.mapM (fun pos => do
      let re ← lookupRTable! pos
      collectDerivFor re)
    return .node cs.toString ⟨branches⟩
  | .inhabitation _ dr _ => return dr
  | .assertion _ dr _ => return dr

section BuildChecker

  inductive BuildMode where
    | directReduce
    | indirectReduce
    | indirectReduce_reflection
  deriving BEq, Hashable, Inhabited

  instance : ToString BuildMode where
    toString : BuildMode → String
    | .directReduce => "directReduce"
    | .indirectReduce => "indirectReduce"
    | .indirectReduce_reflection => "indirectReduce_reflection"

  instance : Lean.KVMap.Value BuildMode where
    toDataValue n := toString n
    ofDataValue?
    | "directReduce" => some .directReduce
    | "indirectReduce" => some .indirectReduce
    | "indirectReduce_reflection" => some .indirectReduce_reflection
    | _ => none

  register_option auto.checker.buildMode : BuildMode := {
    defValue := BuildMode.indirectReduce
    descr := "Mode when building the checker"
  }

  def buildChkStepsExpr : ReifM Expr := do
    let rst ← getRst
    let mut chkSteps := #[]
    for re in (← getRTable) do
      if let .some cs := rst.chkMap.find? re then
        let .some n := rst.findPos? re
          | throwError "buildChkStepsExpr :: Unexpected error"
        chkSteps := chkSteps.push (cs, n)
    -- `ChkMap` are run using `foldl`, so we use `BinTree.ofListFoldl`
    let e := Lean.toExpr (BinTree.ofListFoldl chkSteps.data)
    return e

    -- Given a list of expression of type `ty`, construct the corresponding `BinTree`
  private def exprListToBinTree (l : List Expr) (lvl : Level) (ty : Expr) :=
    (@instToExprBinTreeOfToLevel Expr (instExprToExprId ty) ⟨lvl, Prop⟩).toExpr (BinTree.ofListGet l)

    -- Given a list of expression of type `ty`, construct the corresponding `lctx`
  private def exprListToLCtx (l : List Expr) (lvl : Level) (ty : Expr) :=
    @BinTree.toLCtx Expr ⟨lvl, Prop⟩ (instExprToExprId ty) (BinTree.ofListGet l)

  def buildTyVal : ReifM Expr := do
    let u ← getU
    -- `tyVal : List (Type u)`
    let tyVal : List Expr := (← getTyVal).data.map (fun (e, lvl) =>
      Expr.app (.const ``Embedding.GLift [lvl, u]) e)
    -- `tyValExpr : Nat → Type u`
    let tyValExpr := exprListToLCtx tyVal (.succ u) (.sort (.succ u)) (.sort u)
    return tyValExpr

  /-- **Build `LamVarTy` and `varVal`** -/
  def buildVarExpr (tyValExpr : Expr) : ReifM Expr := do
    let u ← getU
    let lamSortExpr := Expr.const ``LamSort []
    let varValPair := (← getVarVal).data
    let vars ← varValPair.mapM (fun (e, s) => do
      let sExpr := toExpr s
      return Lean.mkApp3 (.const ``varSigmaMk [u]) tyValExpr sExpr (← varValInterp e s))
    return exprListToBinTree vars u (Lean.mkApp2
      (.const ``Sigma [.zero, u]) lamSortExpr
      (.app (.const ``LamSort.interp [u]) tyValExpr))

  /-- **Build `lamILTy` and `ilVal`** -/
  def buildILExpr (tyValExpr : Expr) : ReifM Expr := do
    let u ← getU
    let lamSortExpr := Expr.const ``LamSort []
    let lamILTy := (← getLamILTy).data
    -- `ils : List ((s : LamSort) × ILLift.{u} (s.interp tyVal))`
    let ils ← lamILTy.mapM (fun s => do
      let sExpr := toExpr s
      let ilVal ← mkImportingILLift s
      return Lean.mkApp3 (.const ``ilSigmaMk [u]) tyValExpr sExpr ilVal)
    return exprListToBinTree ils u (Lean.mkApp2
      (.const ``Sigma [.zero, u]) lamSortExpr
      (.app (.const ``ilβ [u]) tyValExpr))

  def buildCPValExpr : ReifM Expr := do
    -- let startTime ← IO.monoMsNow
    let u ← getU
    let tyValExpr ← buildTyVal
    let tyValTy := Expr.forallE `_ (.const ``Nat []) (.sort (.succ u)) .default
    let lamValuationExpr ← Meta.withLetDecl `tyVal tyValTy tyValExpr fun tyValFVarExpr => do
      let varExpr ← buildVarExpr tyValFVarExpr
      let ilExpr ← buildILExpr tyValFVarExpr
      let checkerValuationExpr := Lean.mkApp3 (.const ``CPVal.mk [u]) tyValExpr varExpr ilExpr
      Meta.mkLetFVars #[tyValFVarExpr] checkerValuationExpr
    -- if !(← Meta.isTypeCorrectCore lamValuationExpr) then
    --   throwError "buildLamValuation :: Malformed LamValuation"
    -- trace[auto.buildChecker] "LamValuation typechecked in time {(← IO.monoMsNow) - startTime}"
    return lamValuationExpr

  /-- `lvalExpr` is the `LamValuation` -/
  def buildImportTableExpr (chkValExpr : Expr) : ReifM (Expr × Expr) := do
    -- let startTime ← IO.monoMsNow
    let u ← getU
    let mut importTable : BinTree Expr := BinTree.leaf
    let mut importedFactsTree : BinTree REntry := BinTree.leaf
    for (t, (e, _, ti, n)) in (← getAssertions).toList do
      let tExpr := Lean.toExpr ti
      let ieExpr := Expr.app (.const ``ImportEntry.valid []) tExpr
      let itEntry := Lean.mkApp3 (.const ``importTablePSigmaMk [u]) chkValExpr ieExpr e
      importTable := importTable.insert n itEntry
      if t.maxLooseBVarSucc != 0 || t.maxEVarSucc != 0 then
        throwError "buildImportTableExpr :: Invalid imported fact {t}"
      let veEntry := REntry.valid [] t
      importedFactsTree := importedFactsTree.insert n veEntry
    for (s, (inh, _, n)) in (← getInhabitations).toList do
      let sExpr := Lean.toExpr s
      let ieExpr := Expr.app (.const ``ImportEntry.nonempty []) sExpr
      let (upFunc, _, _, sil) ← updownFunc s
      let inhLift := Lean.mkApp2 (.const ``Nonempty.intro [.succ u]) sil (.app upFunc inh)
      let itEntry := Lean.mkApp3 (.const ``importTablePSigmaMk [u]) chkValExpr ieExpr inhLift
      importTable := importTable.insert n itEntry
      let vEntry := REntry.nonempty s
      importedFactsTree := importedFactsTree.insert n vEntry
    let type := Lean.mkApp2 (.const ``PSigma [.succ .zero, .zero])
      (.const ``ImportEntry []) (.app (.const ``importTablePSigmaβ [u]) chkValExpr)
    let importTableExpr := (@instToExprBinTreeOfToLevel Expr
      (instExprToExprId type) ⟨.zero, Prop⟩).toExpr importTable
    let importedFacts := Lean.toExpr importedFactsTree
    return (importTableExpr, importedFacts)

  /--
    `re` is the entry we want to retrieve from the `validTable`
    The `expr` returned is a proof of the `LamThmValid`-ness of the entry
  -/
  def buildFullCheckerExprFor_directReduce (re : REntry) : ReifM Expr := do
    printCheckerStats
    let startTime ← IO.monoMsNow
    let u ← getU
    let cpvExpr ← buildCPValExpr
    let cpvTy := Expr.const ``CPVal [u]
    let checker ← Meta.withLetDecl `cpval cpvTy cpvExpr fun cpvFVarExpr => do
      let (itExpr, _) ← buildImportTableExpr cpvFVarExpr
      let csExpr ← buildChkStepsExpr
      let .valid lctx t := re
        | throwError "buildFullCheckerExprFor :: {re} is not a `valid` entry"
      let vExpr := Lean.toExpr (← lookupREntryPos! re)
      let eqExpr ← Meta.mkAppM ``Eq.refl #[← Meta.mkAppM ``Option.some #[Lean.toExpr (lctx, t)]]
      let getEntry := Lean.mkApp7 (.const ``Checker.getValidExport_directReduce [u])
        (Lean.toExpr lctx) (Lean.toExpr t) cpvFVarExpr itExpr csExpr vExpr eqExpr
      let getEntry ← Meta.mkLetFVars #[cpvFVarExpr] getEntry
      trace[auto.buildChecker] "Checker expression built in time {(← IO.monoMsNow) - startTime}ms"
      return getEntry
    return checker

  /--
    `re` is the entry we want to retrieve from the `validTable`
    The `expr` returned is a proof of the `LamThmValid`-ness of the entry
  -/
  def buildFullCheckerExprFor_indirectReduce (re : REntry) : ReifM Expr := do
    printCheckerStats
    let startTime ← IO.monoMsNow
    let u ← getU
    let lvtExpr := Lean.toExpr (BinTree.ofListGet ((← getVarVal).map Prod.snd).data)
    let litExpr := Lean.toExpr (BinTree.ofListGet (← getLamILTy).data)
    let cpvExpr ← buildCPValExpr
    let cpvTy := Expr.const ``CPVal [u]
    let checker ← Meta.withLetDecl `cpval cpvTy cpvExpr fun cpvFVarExpr => do
      let (itExpr, ifExpr) ← buildImportTableExpr cpvFVarExpr
      let csExpr ← buildChkStepsExpr
      let .valid lctx t := re
        | throwError "buildFullCheckerExprFor :: {re} is not a `valid` entry"
      let vExpr := Lean.toExpr (← lookupREntryPos! re)
      let hImportExpr ← Meta.mkAppM ``Eq.refl #[ifExpr]
      let hLvtExpr ← Meta.mkAppM ``Eq.refl #[lvtExpr]
      let hLitExpr ← Meta.mkAppM ``Eq.refl #[litExpr]
      let heqExpr ← Meta.mkAppM ``Eq.refl #[← Meta.mkAppM ``Option.some #[Lean.toExpr (lctx, t)]]
      let getEntry := Lean.mkAppN (.const ``Checker.getValidExport_indirectReduce [u])
        #[cpvFVarExpr, itExpr, csExpr, vExpr, ifExpr, hImportExpr,
          lvtExpr, litExpr, hLvtExpr, hLitExpr, Lean.toExpr lctx, Lean.toExpr t, heqExpr]
      let getEntry ← Meta.mkLetFVars #[cpvFVarExpr] getEntry
      trace[auto.buildChecker] "Checker expression built in time {(← IO.monoMsNow) - startTime}ms"
      return getEntry
    return checker

  private def mkNativeAuxDecl (baseName : Name) (type value : Expr) : Reif.ReifM Name := do
    let auxName ← Reif.mkAuxName baseName
    let decl := Declaration.defnDecl {
      name := auxName, levelParams := [], type, value
      hints := .abbrev
      safety := .safe
    }
    let startTime₁ ← IO.monoMsNow
    addDecl decl
    let startTime₂ ← IO.monoMsNow
    withOptions (fun opts => opts.set ``compiler.enableNew false) <| compileDecl decl
    trace[auto.buildChecker] m!"For {auxName}, type checking took {startTime₂ - startTime₁}" ++
      m!"compilation took {(← IO.monoMsNow) - startTime₁}ms"
    return auxName

  /--
    This can be used to shows the issue that compilation of a reduced
      expression exhibits superlinear behaviour. Try the examples in
      `Test/CheckerScalability/Skolemization.lean`
    This function is not intended to be called in practice
  -/
  def compileRunResultExpr : ReifM Name := do
    let runResultExpr := Lean.mkApp3 (.const ``RTable.mk [])
      (Lean.toExpr (← getRTableTree)) (Lean.toExpr (← getMaxEVarSucc))
      (Lean.toExpr (← getLamEVarTyTree))
    mkNativeAuxDecl `lam_ssrefl_rr (Lean.mkConst ``RTable) runResultExpr

  def buildFullCheckerExprFor_indirectReduce_reflection (re : REntry) : ReifM Expr := do
    printCheckerStats
    let startTime ← IO.monoMsNow
    let u ← getU
    let lvtExpr := Lean.toExpr (BinTree.ofListGet ((← getVarVal).map Prod.snd).data)
    let lvtNativeName ← mkNativeAuxDecl `lam_ssrefl_lvt (Expr.app (.const ``BinTree [.zero]) (Lean.mkConst ``LamSort)) lvtExpr
    let litExpr := Lean.toExpr (BinTree.ofListGet (← getLamILTy).data)
    let litNativeName ← mkNativeAuxDecl `lam_ssrefl_lit (Expr.app (.const ``BinTree [.zero]) (Lean.mkConst ``LamSort)) litExpr
    let cpvExpr ← buildCPValExpr
    let cpvTy := Expr.const ``CPVal [u]
    let checker ← Meta.withLetDecl `cpval cpvTy cpvExpr fun cpvFVarExpr => do
      let (itExpr, ifExpr) ← buildImportTableExpr cpvFVarExpr
      let ifNativeName ← mkNativeAuxDecl `lam_ssrefl_if (Expr.app (.const ``BinTree [.zero]) (Lean.mkConst ``REntry)) ifExpr
      let csExpr ← buildChkStepsExpr
      let csNativeName ← mkNativeAuxDecl `lam_ssrefl_cs (Lean.mkConst ``ChkSteps) csExpr
      let .valid lctx t := re
        | throwError "buildFullCheckerExprFor :: {re} is not a `valid` entry"
      let vExpr := Lean.toExpr (← lookupREntryPos! re)
      let hImportExpr ← Meta.mkAppM ``Eq.refl #[Lean.mkConst ifNativeName]
      let hLvtExpr ← Meta.mkAppM ``Eq.refl #[Lean.mkConst lvtNativeName]
      let hLitExpr ← Meta.mkAppM ``Eq.refl #[Lean.mkConst litNativeName]
      let heqBoolExpr := Lean.mkApp7 (.const ``Checker.getValidExport_indirectReduce_reflection_runEq [])
        (Lean.mkConst lvtNativeName) (Lean.mkConst litNativeName) (Lean.mkConst ifNativeName)
        (Lean.mkConst csNativeName) vExpr (Lean.toExpr lctx) (Lean.toExpr t)
      let heqNativeName ← mkNativeAuxDecl `lam_ssrefl_hEq (Lean.mkConst ``Bool) heqBoolExpr
      let heqRflPrf ← Meta.mkEqRefl (toExpr true)
      let heqExpr := mkApp3 (Lean.mkConst ``Lean.ofReduceBool) (Lean.mkConst heqNativeName) (toExpr true) heqRflPrf
      let getEntry := Lean.mkAppN (.const ``Checker.getValidExport_indirectReduce_reflection [u])
        #[cpvFVarExpr, itExpr, csExpr, vExpr, ifExpr, hImportExpr,
          lvtExpr, litExpr, hLvtExpr, hLitExpr, Lean.toExpr lctx, Lean.toExpr t, heqExpr]
      let getEntry ← Meta.mkLetFVars #[cpvFVarExpr] getEntry
      trace[auto.buildChecker] "Checker expression built in time {(← IO.monoMsNow) - startTime}ms"
      return getEntry
    return checker

  def buildFullCheckerExprFor (re : REntry) : ReifM Expr := do
    let buildMode := auto.checker.buildMode.get (← getOptions)
    match buildMode with
    | .directReduce => buildFullCheckerExprFor_directReduce re
    | .indirectReduce => buildFullCheckerExprFor_indirectReduce re
    | .indirectReduce_reflection => buildFullCheckerExprFor_indirectReduce_reflection re

end BuildChecker

end LamReif


namespace Lam2Lam
open Embedding.Lam LamReif

  structure TState where
    typeH2lMap : HashMap Nat Nat            := {}
    -- This field should be in sync with `LamReif.State.tyVal`
    typeL2hMap : Array Nat                  := #[]
    termH2lMap : HashMap Nat Nat            := {}
    -- This field should be in sync with `LamReif.State.varVal`
    termL2hMap : Array Nat                  := #[]
    etomH2lMap : HashMap Nat Nat            := {}
    etomL2hMap : HashMap Nat Nat            := {}
    -- Maps from high-level chkstep to low-level chkstep
    csH2lMap   : HashMap ChkStep ChkStep    := {}

  abbrev TransM := StateRefT TState ReifM

  variable {ω : Type} [BEq ω] [Hashable ω]

  variable {μ : Type} [BEq μ] [Hashable μ]

  @[always_inline]
  instance : Monad TransM :=
    let i := inferInstanceAs (Monad TransM);
    { pure := i.pure, bind := i.bind }

  instance : Inhabited (TransM α) where
    default := fun _ => throw default

  #genMonadState TransM

  def transTypeAtom (a : Nat) (val : Expr × Level) : TransM Nat := do
    let typeH2lMap ← getTypeH2lMap
    match typeH2lMap.find? a with
    | .some n => return n
    | .none =>
      let idx := typeH2lMap.size
      setTypeH2lMap (typeH2lMap.insert a idx)
      setTypeL2hMap ((← getTypeL2hMap).push a)
      setTyVal ((← getTyVal).push val)
      setTyVarMap ((← getTyVarMap).insert val.fst idx)
      return idx

  /--
    When translating `Lam` to `Lam` in `Lam2Lam`, make sure that
      the `LamSort` in this `val` is already translated.
  -/
  def transTermAtom (a : Nat) (val : Expr × LamSort) : TransM Nat := do
    let termH2lMap ← getTermH2lMap
    match termH2lMap.find? a with
    | .some n => return n
    | .none =>
      let idx := termH2lMap.size
      setTermH2lMap (termH2lMap.insert a idx)
      setTermL2hMap ((← getTermL2hMap).push a)
      setVarVal ((← getVarVal).push val)
      setVarMap ((← getVarMap).insert val.fst idx)
      return idx

  def addEtomTranslation (eH : Nat) (eL : Nat) : TransM Unit := do
    setEtomH2lMap ((← getEtomH2lMap).insert eH eL)
    setEtomL2hMap ((← getEtomL2hMap).insert eL eH)

  -- We're translating `Lam` to `Lam`. We call the first `Lam`
  --   the `high-level` one, and the second `Lam` the `low-level` one.

  def transLamSort (ref : State) : LamSort → TransM LamSort
  | .atom n => do
    let (val, _) ← (lookupTyVal! n).run ref
    return .atom (← transTypeAtom n val)
  | .base b => return .base b
  | .func arg res => .func <$> transLamSort ref arg <*> transLamSort ref res

  private def transLamBaseTermILErr := "transLamBaseTerm :: Import versions of logical constants should not occur here"

  def transLamBaseTerm (ref : State) : LamBaseTerm → TransM LamBaseTerm
  | .eqI _ => throwError transLamBaseTermILErr
  | .forallEI _ => throwError transLamBaseTermILErr
  | .existEI _ => throwError transLamBaseTermILErr
  | .iteI _ => throwError transLamBaseTermILErr
  | .eq s => .eq <$> transLamSort ref s
  | .forallE s => .forallE <$> transLamSort ref s
  | .existE s => .existE <$> transLamSort ref s
  | .ite s => .ite <$> transLamSort ref s
  | b => return b

  mutual

    partial def transEtom (ref : State) (e : Nat) : TransM Nat := do
      if !((← getEtomH2lMap).contains e) then
        let (cs, _) ← (lookupEtomChkStep! e).run ref
        trace[auto.buildChecker] "Collecting for etom {e} by ChkStep {cs}"
        let _ ← processChkStep ref cs
      let .some n := (← getEtomH2lMap).find? e
        | throwError "transEtom :: Cannot find translation of etom {e}"
      return n

    partial def transLamTerm (ref : State) : LamTerm → TransM LamTerm
    | .atom n => do
      let ((e, s), _) ← (lookupVarVal! n).run ref
      let s' ← transLamSort ref s
      return .atom (← transTermAtom n (e, s'))
    | .etom n => return .etom (← transEtom ref n)
    | .base b => .base <$> transLamBaseTerm ref b
    | .bvar n => return .bvar n
    | .lam s t => .lam <$> transLamSort ref s <*> transLamTerm ref t
    | .app s fn arg => .app <$> transLamSort ref s <*> transLamTerm ref fn <*> transLamTerm ref arg

    partial def transREntry (ref : State) : REntry → TransM REntry
    | .wf lctx s t => do
      return .wf (← lctx.mapM (transLamSort ref)) (← transLamSort ref s) (← transLamTerm ref t)
    | .valid lctx t => do
      return .valid (← lctx.mapM (transLamSort ref)) (← transLamTerm ref t)
    | .nonempty s => .nonempty <$> transLamSort ref s

    partial def transPos (ref : State) (n : Nat) : TransM Nat := do
      let (hre, _) ← (lookupRTable! n).run ref
      collectProofFor ref hre
      lookupREntryPos! (← transREntry ref hre)

    partial def transChkStep (ref : State) : ChkStep → TransM ChkStep
    | .c cs => ChkStep.c <$>
      match cs with
      | .validOfHeadBeta pos => return .validOfHeadBeta (← transPos ref pos)
      | .validOfBetaBounded pos bound => return .validOfBetaBounded (← transPos ref pos) bound
      | .validOfExtensionalize pos => return .validOfExtensionalize (← transPos ref pos)
      | .validOfEqSymm pos => return .validOfEqSymm (← transPos ref pos)
      | .validOfMp pos rw => return .validOfMp (← transPos ref pos) (← transPos ref rw)
      | .validOfMpAll pos rw => return .validOfMpAll (← transPos ref pos) (← transPos ref rw)
      | .validOfCongrArg pos rw => return .validOfCongrArg (← transPos ref pos) (← transPos ref rw)
      | .validOfCongrFun pos rw => return .validOfCongrFun (← transPos ref pos) (← transPos ref rw)
      | .validOfCongr pos rwFn rwArg => return .validOfCongr (← transPos ref pos) (← transPos ref rwFn) (← transPos ref rwArg)
      | .validOfCongrArgs pos rws => return .validOfCongrArgs (← transPos ref pos) (← rws.mapM (transPos ref))
      | .validOfCongrFunN pos rw n => return .validOfCongrFunN (← transPos ref pos) (← transPos ref rw) n
      | .validOfCongrs pos rwFn rwArgs => return .validOfCongrs (← transPos ref pos) (← transPos ref rwFn) (← rwArgs.mapM (transPos ref))
    | .ca cs => ChkStep.ca <$>
      match cs with
      | .validOfEtaExpand1At pos occ => return .validOfEtaExpand1At (← transPos ref pos) occ
      | .validOfEtaReduce1At pos occ => return .validOfEtaReduce1At (← transPos ref pos) occ
      | .validOfEtaExpandNAt pos n occ => return .validOfEtaExpandNAt (← transPos ref pos) n occ
      | .validOfEtaReduceNAt pos n occ => return .validOfEtaReduceNAt (← transPos ref pos) n occ
      | .validOfExtensionalizeEqAt pos occ => return .validOfExtensionalizeEqAt (← transPos ref pos) occ
      | .validOfExtensionalizeEqFNAt pos n occ => return .validOfExtensionalizeEqFNAt (← transPos ref pos) n occ
      | .validOfIntensionalizeEqAt pos occ => return .validOfIntensionalizeEqAt (← transPos ref pos) occ
    | .e cs => ChkStep.e <$>
      match cs with
      | .skolemize pos => return .skolemize (← transPos ref pos)
      | .define t => return .define (← transLamTerm ref t)
    | .f cs => ChkStep.f <$>
      match cs with
      | .boolFacts => return .boolFacts
      | .iteSpec s => do return .iteSpec (← transLamSort ref s)
    | .i cs => ChkStep.i <$>
      match cs with
      | .validOfBVarLower pv pn => return .validOfBVarLower (← transPos ref pv) (← transPos ref pn)
      | .validOfBVarLowers pv pns => return .validOfBVarLowers (← transPos ref pv) (← pns.mapM (transPos ref))
      | .validOfImp p₁₂ p₁ => return .validOfImp (← transPos ref p₁₂) (← transPos ref p₁)
      | .validOfImps imp ps => return .validOfImps (← transPos ref imp) (← ps.mapM (transPos ref))
      | .validOfInstantiate1 pos arg => return .validOfInstantiate1 (← transPos ref pos) (← transLamTerm ref arg)
      | .validOfInstantiate pos args => return .validOfInstantiate (← transPos ref pos) (← args.mapM (transLamTerm ref))
      | .validOfInstantiateRev pos args => return .validOfInstantiateRev (← transPos ref pos) (← args.mapM (transLamTerm ref))
      | .validOfEqualize pos occ => return .validOfEqualize (← transPos ref pos) occ
      | .validOfAndLeft pos occ => return .validOfAndLeft (← transPos ref pos) occ
      | .validOfAndRight pos occ => return .validOfAndRight (← transPos ref pos) occ
    | .l cs => ChkStep.l <$>
      match cs with
      | .validOfIntro1F pos => return .validOfIntro1F (← transPos ref pos)
      | .validOfIntro1H pos => return .validOfIntro1H (← transPos ref pos)
      | .validOfIntros pos idx => return .validOfIntros (← transPos ref pos) idx
      | .validOfRevert pos => return .validOfRevert (← transPos ref pos)
      | .validOfReverts pos idx => return .validOfReverts (← transPos ref pos) idx
      | .validOfAppend pos ex => return .validOfAppend (← transPos ref pos) (← ex.mapM (transLamSort ref))
      | .validOfPrepend pos ex => return .validOfPrepend (← transPos ref pos) (← ex.mapM (transLamSort ref))
    | .n cs => ChkStep.n <$>
      match cs with
      | .nonemptyOfAtom n => do
        let .atom n' ← transLamTerm ref (.atom n)
          | throwError "transChkStep :: Unexpected error"
        return .nonemptyOfAtom n'
      | .nonemptyOfEtom n => do
        let .etom n' ← transLamTerm ref (.etom n)
          | throwError "transChkStep :: Unexpected error"
        return .nonemptyOfEtom n'
    | .p cs pos occ => return ChkStep.p cs (← transPos ref pos) occ
    | .w cs => ChkStep.w <$>
      match cs with
      | .wfOfCheck lctx t => return .wfOfCheck (← lctx.mapM (transLamSort ref)) (← transLamTerm ref t)
      | .wfOfAppend pos ex => return .wfOfAppend (← transPos ref pos) (← ex.mapM (transLamSort ref))
      | .wfOfPrepend pos ex => return .wfOfPrepend (← transPos ref pos) (← ex.mapM (transLamSort ref))
      | .wfOfHeadBeta pos => return .wfOfHeadBeta (← transPos ref pos)
      | .wfOfBetaBounded pos bound => return .wfOfBetaBounded (← transPos ref pos) bound

    partial def processChkStep (ref : State) (cs : ChkStep) : TransM EvalResult := do
      if let .some cs' := (← getCsH2lMap).find? cs then
        return ← LamReif.lookupChkStepResult! cs'
      let cs' ← transChkStep ref cs
      setCsH2lMap ((← getCsH2lMap).insert cs cs')
      let (true, er) ← newChkStep cs' .none
        | throwError "processChkStep :: Unexpected error"
      trace[auto.buildChecker] "Checkstep {cs} translated to {cs'}, producing {er}"
      match er with
      | .newEtomWithValid .. => do
        let newEtoms ← LamReif.lookupChkStepEtom! cs'
        let oldEtoms ← (LamReif.lookupChkStepEtom! cs).run' ref
        for (new, old) in newEtoms.zip oldEtoms do
          addEtomTranslation old new
      | _ => pure .unit
      return er

    -- Collect essential chksteps and assertions from the high-level `lam`
    --   into the low-level `lam` such that the low-level `lam` proves `re`
    partial def collectProofFor (ref : State) (hre : REntry) : TransM Unit := do
      if let .some _ := (← getChkMap).find? hre then
        return
      let (highLvlProof, _) ← (lookupREntryProof! hre).run ref
      match highLvlProof with
      | .chkStep cs =>
        trace[auto.buildChecker] "Collecting for {hre} by ChkStep {cs}"
        let er ← processChkStep ref cs
        match er with
        | .fail => throwError "collectProofFor :: Unexpected evaluation result"
        | .addEntry reNew => do
          let expectedEntry ← transREntry ref hre
          if expectedEntry != reNew then throwError "collectProofFor :: Entry mismatch"
        | .newEtomWithValid _ lctx t => do
          let expectedEntry ← transREntry ref hre
          if expectedEntry != .valid lctx t then throwError "collectProofFor :: Entry mismatch"
      | .inhabitation e deriv _ =>
        let .nonempty hs := hre
          | throwError "collectProofFor :: Unexpected error"
        let s ← transLamSort ref hs
        newInhabitation e deriv s
        trace[auto.buildChecker] "Inhabitation fact {hs} translated to {s}"
      | .assertion e deriv _ =>
        let .valid [] ht := hre
          | throwError "collectProofFor :: Unexpected error"
        let t ← transLamTerm ref ht
        newAssertion e deriv t
        trace[auto.buildChecker] "Import fact {ht} translated to {t}"

  end

  /--
    Delete irrelevant Valuations and ChkSteps, but make sure that
      entries in `res` are still provable
  -/
  def optimizedStateFor (res : Array REntry) : LamReif.ReifM State := do
    let ref ← get
    let (_, s') ← ((res.foldlM (fun _ re => collectProofFor ref re) ()).run {}).run { u := ref.u }
    return s'

end Lam2Lam

namespace LamReif
open Embedding.Lam

/-- Build optimized checker = Optimize state + Build full checker -/
def buildOptimizedCheckerExprFor (re : REntry) : ReifM Expr := do
  let s' ← Lam2Lam.optimizedStateFor #[re]
  let (e, _) ← (buildFullCheckerExprFor re).run s'
  return e

register_option auto.optimizeCheckerProof : Bool := {
  defValue := true
  descr := "Enable/Disable checker proof optimization"
}

/-- Decide whether to optimize based on option -/
def buildCheckerExprFor (re : REntry) : ReifM Expr := do
  match auto.optimizeCheckerProof.get (← getOptions) with
  | true => buildOptimizedCheckerExprFor re
  | false => buildFullCheckerExprFor re

end Auto.LamReif
